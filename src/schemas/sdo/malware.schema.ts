import { z } from 'zod/v4';
import { createStixTypeValidator } from '../common/stix-type.js';
import { softwareSchema } from './software.schema.js';
import {
  createStixIdValidator,
  killChainPhaseSchema,
  stixTimestampSchema,
} from '../common/index.js';
import {
  MalwareCapabilityOV,
  ProcessorArchitectureOV,
  ImplementationLanguageOV,
  MalwareTypeOV,
} from '../common/open-vocabulary.js';

/////////////////////////////////////
//
// file and artifact type for sample_refs
//
/////////////////////////////////////

export const stixFileType = createStixIdValidator('file').meta(
  { description: 'Used to specify the file stixType of the sample_refs property.', }
);

export const stixArtifactType = createStixIdValidator('artifact').meta(
  { description: 'Used to specify the artifact stixType of the sample_refs property.', }
);

/////////////////////////////////////
//
// Malware Schema
//
/////////////////////////////////////

export const malwareSchema = softwareSchema
  .extend({
    id: createStixIdValidator('malware'),

    type: createStixTypeValidator('malware'),

    is_family: z
      .boolean()
      .meta(
        { description: 'Whether the object represents a malware family (if true) or a malware instance (if false)', }
      ),

    // Not used in ATT&CK Malware but defined in STIX
    malware_types: z
      .array(MalwareTypeOV)
      .meta({ description: 'A set of categorizations for the malware being described.' })
      .optional(),

    // Not used in ATT&CK Malware but defined in STIX
    kill_chain_phases: z
      .array(killChainPhaseSchema)
      .meta({ description: 'The list of Kill Chain Phases for which this malware can be used.' })
      .optional(),

    // Not used in ATT&CK Malware but defined in STIX
    first_seen: stixTimestampSchema
      .optional()
      .meta({ description: 'The time that this malware instance or malware family was first seen.' }),

    // Not used in ATT&CK Malware but defined in STIX
    last_seen: stixTimestampSchema
      .optional()
      .meta({ description: 'The time that this malware family or malware instance was last seen.' }),

    // Not used in ATT&CK Malware but defined in STIX
    os_execution_envs: z
      .array(z.string())
      .meta({ description: 'The operating systems that the malware family or malware instance is executable on. This applies to virtualized operating systems as well as those running on bare metal.' },)
      .optional(),

    // Not used in ATT&CK Malware but defined in STIX
    architecture_execution_envs: z
      .array(ProcessorArchitectureOV)
      .meta({ description: 'The processor architectures (e.g., x86, ARM, etc.) that the malware instance or family is executable on.' })
      .optional(),

    // Not used in ATT&CK Malware but defined in STIX
    implementation_languages: z
      .array(ImplementationLanguageOV)
      .meta({ description: 'The programming language(s) used to implement the malware instance or family.' })
      .optional(),

    // Not used in ATT&CK Malware but defined in STIX
    capabilities: z
      .array(MalwareCapabilityOV)
      .meta({ description: 'Any of the capabilities identified for the malware instance or family.' })
      .optional(),

    // Not used in ATT&CK Malware but defined in STIX
    sample_refs: z
      .array(z.union([stixArtifactType, stixFileType]))
      .optional()
      .meta({ description: 'The sample_refs property specifies a list of identifiers of the SCO file or artifact objects associated with this malware instance(s) or family.' }),
  })
  .strict()
  .check(ctx => {
    //==============================================================================
    // Validate external references
    //==============================================================================

    const { external_references } = ctx.value;
    const attackIdEntry = external_references[0];
    if (!attackIdEntry.external_id) {
      ctx.issues.push({
        code: 'custom',
        message: 'ATT&CK ID must be defined in the first external_references entry.',
        path: ['external_references', 0, 'external_id'],
        input: ctx.value.id
      });
    } else {
      const idRegex = /^S\d{4}$/;
      if (!idRegex.test(attackIdEntry.external_id)) {
        ctx.issues.push({
          code: 'custom',
          message: `The first external_reference must match the ATT&CK ID format S####}.`,
          path: ['external_references', 0, 'external_id'],
          input: ctx.value.id
        });
      }
    }

    //==============================================================================
    // Validate x_mitre_aliases
    //==============================================================================

    // The object's name MUST be listed as the first alias in the x_mitre_aliases field
    const { x_mitre_aliases, name } = ctx.value;
    if (x_mitre_aliases && x_mitre_aliases.length > 0) {
      if (!(x_mitre_aliases[0] === name)) {
        ctx.issues.push({
          code: 'custom',
          path: ['x_mitre_aliases'],
          message: "The first alias must match the object's name",
          input: ctx.value.id
        });
      }
    }

    //==============================================================================
    // Validate x_mitre_old_attack_id
    //==============================================================================
    const idRegex = /^MOB-S\d{4}$/;
    const oldAttackId = ctx.value.x_mitre_old_attack_id;
    if (typeof oldAttackId === 'string' && !idRegex.test(oldAttackId)) {
      ctx.issues.push({
        code: 'custom',
        message: `x_mitre_old_attack_id for malware and tool need to be in the format MOB-S####}.`,
        path: ['x_mitre_old_attack_id'],
        input: ctx.value.id
      });
    }
  });

// Define the type for Malware
export type Malware = z.infer<typeof malwareSchema>;
