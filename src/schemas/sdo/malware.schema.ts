import { z } from 'zod';
import { createStixTypeValidator } from '../common/stix-type.js';
import { softwareSchema } from './software.schema.js';
import {
  createAttackExternalReferencesSchema,
  createOldMitreAttackIdSchema,
  createStixIdValidator,
  killChainPhaseSchema,
  stixTimestampSchema,
} from '../common/index.js';
import {
  MalwareCapabilitiesOpenVocabulary,
  ProcessorArchitecturesOpenVocabulary,
  ImplementationLanguagesOpenVocabulary,
  MalwareTypeOpenVocabulary,
} from '../common/open-vocabulary.js';
import {
  createFirstAliasRefinement,
  createFirstXMitreAliasRefinement,
} from '@/refinements/index.js';

/////////////////////////////////////
//
// file and artifact type for sample_refs
//
/////////////////////////////////////

export const stixFileType = createStixIdValidator('file').describe(
  'Used to specify the file stixType of the sample_refs property.',
);

export const stixArtifactType = createStixIdValidator('artifact').describe(
  'Used to specify the artifact stixType of the sample_refs property.',
);

/////////////////////////////////////
//
// Malware Schema
//
/////////////////////////////////////

export const extensibleMalwareSchema = softwareSchema
  .extend({
    id: createStixIdValidator('malware'),

    type: createStixTypeValidator('malware'),

    is_family: z
      .boolean()
      .describe(
        'Whether the object represents a malware family (if true) or a malware instance (if false)',
      ),

    // Not used in ATT&CK Malware but defined in STIX
    malware_types: z
      .array(MalwareTypeOpenVocabulary)
      .describe('A set of categorizations for the malware being described.')
      .optional(),

    // Not used in ATT&CK Malware but defined in STIX
    kill_chain_phases: z
      .array(killChainPhaseSchema)
      .describe('The list of Kill Chain Phases for which this malware can be used.')
      .optional(),

    // Not used in ATT&CK Malware but defined in STIX
    first_seen: stixTimestampSchema
      .optional()
      .describe('The time that this malware instance or malware family was first seen.'),

    // Not used in ATT&CK Malware but defined in STIX
    last_seen: stixTimestampSchema
      .optional()
      .describe('The time that this malware family or malware instance was last seen.'),

    external_references: createAttackExternalReferencesSchema('malware'),

    x_mitre_old_attack_id: createOldMitreAttackIdSchema('malware').optional(),

    // Not used in ATT&CK Malware but defined in STIX
    os_execution_envs: z
      .array(z.string())
      .describe(
        'The operating systems that the malware family or malware instance is executable on. This applies to virtualized operating systems as well as those running on bare metal.',
      )
      .optional(),

    // Not used in ATT&CK Malware but defined in STIX
    architecture_execution_envs: z
      .array(ProcessorArchitecturesOpenVocabulary)
      .describe(
        'The processor architectures (e.g., x86, ARM, etc.) that the malware instance or family is executable on.',
      )
      .optional(),

    // Not used in ATT&CK Malware but defined in STIX
    implementation_languages: z
      .array(ImplementationLanguagesOpenVocabulary)
      .describe('The programming language(s) used to implement the malware instance or family.')
      .optional(),

    // Not used in ATT&CK Malware but defined in STIX
    capabilities: z
      .array(MalwareCapabilitiesOpenVocabulary)
      .describe('Any of the capabilities identified for the malware instance or family.')
      .optional(),

    // Not used in ATT&CK Malware but defined in STIX
    sample_refs: z
      .array(z.union([stixArtifactType, stixFileType]))
      .optional()
      .describe(
        'The sample_refs property specifies a list of identifiers of the SCO file or artifact objects associated with this malware instance(s) or family.',
      ),
  })
  .strict();

// Create refinement instances
const validateFirstXMitreAlias = createFirstXMitreAliasRefinement();
const validateFirstAlias = createFirstAliasRefinement();

// Apply a single refinement that combines both refinements
export const malwareSchema = extensibleMalwareSchema.superRefine((schema, ctx) => {
  validateFirstAlias(schema, ctx);
  validateFirstXMitreAlias(schema, ctx);
});

// Define the type for Malware
export type Malware = z.infer<typeof extensibleMalwareSchema>;
