"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[1486],{1898:(r,n,e)=>{e.r(n),e.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"how-to-guides/error-handling","title":"How to Handle Parsing Errors Gracefully","description":"Implement robust error handling for production applications","source":"@site/docs/how-to-guides/error-handling.mdx","sourceDirName":"how-to-guides","slug":"/how-to-guides/error-handling","permalink":"/attack-data-model/docs/how-to-guides/error-handling","draft":false,"unlisted":false,"editUrl":"https://github.com/mitre-attack/attack-data-model/tree/main/docusaurus/docs/how-to-guides/error-handling.mdx","tags":[],"version":"current","lastUpdatedBy":"Jared Ondricek","lastUpdatedAt":1758571766000,"frontMatter":{},"sidebar":"documentationSidebar","previous":{"title":"How to Validate Custom STIX Bundles","permalink":"/attack-data-model/docs/how-to-guides/validate-bundles"},"next":{"title":"How to Optimize Performance","permalink":"/attack-data-model/docs/how-to-guides/performance"}}');var a=e(4848),o=e(8453),s=e(1367);const i={},l="How to Handle Parsing Errors Gracefully",c={},d=[{value:"Problem",id:"problem",level:2},{value:"Solution Overview",id:"solution-overview",level:2},{value:"Step 1: Understanding Error Types",id:"step-1-understanding-error-types",level:2},{value:"Step 2: Basic Error Handling Pattern",id:"step-2-basic-error-handling-pattern",level:2},{value:"Step 3: Data Completeness Validation",id:"step-3-data-completeness-validation",level:2},{value:"Step 4: Retry Logic with Exponential Backoff",id:"step-4-retry-logic-with-exponential-backoff",level:2},{value:"Step 5: Fallback Data Sources",id:"step-5-fallback-data-sources",level:2},{value:"Step 6: Error Reporting and Monitoring",id:"step-6-error-reporting-and-monitoring",level:2},{value:"Step 7: Application-Level Error Handling",id:"step-7-application-level-error-handling",level:2},{value:"Step 8: Usage Example",id:"step-8-usage-example",level:2}];function u(r){const n={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...r.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"how-to-handle-parsing-errors-gracefully",children:"How to Handle Parsing Errors Gracefully"})}),"\n",(0,a.jsx)(s.A,{}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Implement robust error handling for production applications"})}),"\n",(0,a.jsx)(n.p,{children:"When working with ATT&CK data in production, you need comprehensive error handling to manage data source failures, validation errors, and parsing issues. This guide shows you how to build resilient applications that handle errors gracefully while providing meaningful feedback."}),"\n",(0,a.jsx)(n.h2,{id:"problem",children:"Problem"}),"\n",(0,a.jsx)(n.p,{children:"You need to handle various error scenarios:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Network failures when loading remote data sources"}),"\n",(0,a.jsx)(n.li,{children:"Invalid STIX data that fails validation"}),"\n",(0,a.jsx)(n.li,{children:"Missing or corrupted data files"}),"\n",(0,a.jsx)(n.li,{children:"Partial parsing failures in relaxed mode"}),"\n",(0,a.jsx)(n.li,{children:"Timeout issues with large datasets"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"solution-overview",children:"Solution Overview"}),"\n",(0,a.jsx)(n.p,{children:"Implement layered error handling with specific strategies for different error types, comprehensive logging, and graceful degradation."}),"\n",(0,a.jsx)(n.h2,{id:"step-1-understanding-error-types",children:"Step 1: Understanding Error Types"}),"\n",(0,a.jsx)(n.p,{children:"The ATT&CK Data Model can throw several types of errors:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import {\r\n    registerDataSource,\r\n    loadDataModel,\r\n    DataSource,\r\n    DataSourceError,\r\n    ValidationError\r\n} from '@mitre-attack/attack-data-model';\r\nimport { ZodError } from 'zod';\r\n\r\n// Error types you'll encounter:\r\n// 1. Network/IO errors - failed downloads, missing files\r\n// 2. Zod validation errors - schema validation failures\r\n// 3. Data source errors - configuration issues\r\n// 4. Parsing errors - malformed JSON, invalid STIX\r\n// 5. Registration errors - data source registration failures\n"})}),"\n",(0,a.jsx)(n.h2,{id:"step-2-basic-error-handling-pattern",children:"Step 2: Basic Error Handling Pattern"}),"\n",(0,a.jsx)(n.p,{children:"Create a robust data loading function:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import fs from 'fs';\r\nimport { setTimeout } from 'timers/promises';\r\n\r\ninterface LoadResult {\r\n    success: boolean;\r\n    dataModel?: AttackDataModel;\r\n    errors: string[];\r\n    warnings: string[];\r\n}\r\n\r\nasync function loadAttackDataSafely(\r\n    source: 'attack' | 'file' | 'url',\r\n    options: any\r\n): Promise<LoadResult> {\r\n    const result: LoadResult = {\r\n        success: false,\r\n        errors: [],\r\n        warnings: []\r\n    };\r\n\r\n    try {\r\n        // Step 1: Create data source with validation\r\n        console.log(`\ud83d\udce1 Loading ATT&CK data from ${source}...`);\r\n\r\n        const dataSource = new DataSource({\r\n            source,\r\n            parsingMode: 'relaxed', // More forgiving for error scenarios\r\n            ...options\r\n        });\r\n\r\n        // Step 2: Register with timeout\r\n        const uuid = await Promise.race([\r\n            registerDataSource(dataSource),\r\n            setTimeout(30000).then(() => {\r\n                throw new Error('Registration timeout after 30 seconds');\r\n            })\r\n        ]);\r\n\r\n        if (!uuid) {\r\n            result.errors.push('Failed to register data source - no UUID returned');\r\n            return result;\r\n        }\r\n\r\n        console.log('\u2705 Data source registered successfully');\r\n\r\n        // Step 3: Load data model\r\n        const dataModel = loadDataModel(uuid);\r\n\r\n        // Step 4: Validate data completeness\r\n        const validation = validateDataCompleteness(dataModel);\r\n        result.warnings.push(...validation.warnings);\r\n\r\n        if (validation.criticalIssues.length > 0) {\r\n            result.errors.push(...validation.criticalIssues);\r\n            return result;\r\n        }\r\n\r\n        result.success = true;\r\n        result.dataModel = dataModel;\r\n\r\n        console.log(`\u2705 Successfully loaded ${dataModel.techniques.length} techniques`);\r\n\r\n    } catch (error) {\r\n        result.errors.push(handleLoadingError(error));\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction handleLoadingError(error: unknown): string {\r\n    if (error instanceof ZodError) {\r\n        return `Validation error: ${error.errors.map(e =>\r\n            `${e.path.join('.')}: ${e.message}`\r\n        ).join(', ')}`;\r\n    }\r\n\r\n    if (error instanceof Error) {\r\n        // Network/timeout errors\r\n        if (error.message.includes('timeout')) {\r\n            return 'Request timeout - data source may be slow or unavailable';\r\n        }\r\n\r\n        // File system errors\r\n        if (error.message.includes('ENOENT')) {\r\n            return 'File not found - check file path and permissions';\r\n        }\r\n\r\n        // Network errors\r\n        if (error.message.includes('ENOTFOUND') || error.message.includes('ECONNREFUSED')) {\r\n            return 'Network error - check internet connection and URL';\r\n        }\r\n\r\n        return `Error: ${error.message}`;\r\n    }\r\n\r\n    return `Unknown error: ${String(error)}`;\r\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"step-3-data-completeness-validation",children:"Step 3: Data Completeness Validation"}),"\n",(0,a.jsx)(n.p,{children:"Validate that loaded data meets minimum requirements:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface DataValidation {\r\n    warnings: string[];\r\n    criticalIssues: string[];\r\n    stats: {\r\n        techniques: number;\r\n        tactics: number;\r\n        groups: number;\r\n        software: number;\r\n    };\r\n}\r\n\r\nfunction validateDataCompleteness(dataModel: AttackDataModel): DataValidation {\r\n    const result: DataValidation = {\r\n        warnings: [],\r\n        criticalIssues: [],\r\n        stats: {\r\n            techniques: dataModel.techniques.length,\r\n            tactics: dataModel.tactics.length,\r\n            groups: dataModel.groups.length,\r\n            software: dataModel.malware.length + dataModel.tools.length\r\n        }\r\n    };\r\n\r\n    // Critical issues - data is unusable\r\n    if (result.stats.techniques === 0) {\r\n        result.criticalIssues.push('No techniques loaded - data source may be invalid');\r\n    }\r\n\r\n    if (result.stats.tactics === 0) {\r\n        result.criticalIssues.push('No tactics loaded - core ATT&CK structure missing');\r\n    }\r\n\r\n    // Warnings - data is usable but incomplete\r\n    if (result.stats.techniques < 100) {\r\n        result.warnings.push(`Only ${result.stats.techniques} techniques loaded - expected 150+`);\r\n    }\r\n\r\n    if (result.stats.groups < 50) {\r\n        result.warnings.push(`Only ${result.stats.groups} groups loaded - expected 100+`);\r\n    }\r\n\r\n    if (result.stats.software < 200) {\r\n        result.warnings.push(`Only ${result.stats.software} software items loaded - expected 400+`);\r\n    }\r\n\r\n    // Check relationship integrity\r\n    const brokenRelationships = checkRelationshipIntegrity(dataModel);\r\n    if (brokenRelationships.length > 0) {\r\n        result.warnings.push(`${brokenRelationships.length} broken relationships found`);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction checkRelationshipIntegrity(dataModel: AttackDataModel): string[] {\r\n    const issues: string[] = [];\r\n\r\n    // Check technique-tactic relationships\r\n    dataModel.techniques.forEach(technique => {\r\n        try {\r\n            const tactics = technique.getTactics();\r\n            if (tactics.length === 0) {\r\n                issues.push(`Technique ${technique.name} has no associated tactics`);\r\n            }\r\n        } catch (error) {\r\n            issues.push(`Error getting tactics for technique ${technique.name}: ${error}`);\r\n        }\r\n    });\r\n\r\n    return issues.slice(0, 10); // Limit to first 10 issues\r\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"step-4-retry-logic-with-exponential-backoff",children:"Step 4: Retry Logic with Exponential Backoff"}),"\n",(0,a.jsx)(n.p,{children:"Implement retry logic for transient failures:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface RetryOptions {\r\n    maxAttempts: number;\r\n    baseDelay: number;\r\n    maxDelay: number;\r\n    backoffMultiplier: number;\r\n}\r\n\r\nasync function loadWithRetry(\r\n    loadFunction: () => Promise<LoadResult>,\r\n    options: RetryOptions = {\r\n        maxAttempts: 3,\r\n        baseDelay: 1000,\r\n        maxDelay: 10000,\r\n        backoffMultiplier: 2\r\n    }\r\n): Promise<LoadResult> {\r\n    let lastResult: LoadResult | null = null;\r\n\r\n    for (let attempt = 1; attempt <= options.maxAttempts; attempt++) {\r\n        console.log(`\ud83d\udce1 Attempt ${attempt}/${options.maxAttempts}`);\r\n\r\n        try {\r\n            const result = await loadFunction();\r\n\r\n            if (result.success) {\r\n                if (attempt > 1) {\r\n                    console.log(`\u2705 Succeeded on attempt ${attempt}`);\r\n                }\r\n                return result;\r\n            }\r\n\r\n            lastResult = result;\r\n\r\n            // Don't retry for certain error types\r\n            const nonRetryableErrors = [\r\n                'File not found',\r\n                'Validation error',\r\n                'Invalid configuration'\r\n            ];\r\n\r\n            const hasNonRetryableError = result.errors.some(error =>\r\n                nonRetryableErrors.some(pattern => error.includes(pattern))\r\n            );\r\n\r\n            if (hasNonRetryableError) {\r\n                console.log('\u274c Non-retryable error detected, aborting retries');\r\n                break;\r\n            }\r\n\r\n        } catch (error) {\r\n            lastResult = {\r\n                success: false,\r\n                errors: [`Attempt ${attempt} failed: ${error}`],\r\n                warnings: []\r\n            };\r\n        }\r\n\r\n        // Calculate delay with exponential backoff\r\n        if (attempt < options.maxAttempts) {\r\n            const delay = Math.min(\r\n                options.baseDelay * Math.pow(options.backoffMultiplier, attempt - 1),\r\n                options.maxDelay\r\n            );\r\n\r\n            console.log(`\u23f3 Waiting ${delay}ms before retry...`);\r\n            await setTimeout(delay);\r\n        }\r\n    }\r\n\r\n    console.log(`\u274c All ${options.maxAttempts} attempts failed`);\r\n    return lastResult || {\r\n        success: false,\r\n        errors: ['All retry attempts failed'],\r\n        warnings: []\r\n    };\r\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"step-5-fallback-data-sources",children:"Step 5: Fallback Data Sources"}),"\n",(0,a.jsx)(n.p,{children:"Implement fallback strategies when primary sources fail:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface DataSourceConfig {\r\n    primary: DataSource;\r\n    fallbacks: DataSource[];\r\n    cacheOptions?: {\r\n        enabled: boolean;\r\n        ttl: number; // Time to live in seconds\r\n        path: string;\r\n    };\r\n}\r\n\r\nclass RobustAttackLoader {\r\n    private cache = new Map<string, { data: AttackDataModel; timestamp: number }>();\r\n\r\n    async loadWithFallbacks(config: DataSourceConfig): Promise<LoadResult> {\r\n        const sources = [config.primary, ...config.fallbacks];\r\n        let lastResult: LoadResult | null = null;\r\n\r\n        // Try cache first if enabled\r\n        if (config.cacheOptions?.enabled) {\r\n            const cached = this.tryLoadFromCache(config.cacheOptions.path, config.cacheOptions.ttl);\r\n            if (cached.success) {\r\n                console.log('\u2705 Loaded data from cache');\r\n                return cached;\r\n            }\r\n        }\r\n\r\n        // Try each data source\r\n        for (let i = 0; i < sources.length; i++) {\r\n            const source = sources[i];\r\n            const isLastSource = i === sources.length - 1;\r\n\r\n            console.log(`\ud83c\udfaf Trying data source ${i + 1}/${sources.length}`);\r\n\r\n            const result = await loadWithRetry(async () => {\r\n                return await loadAttackDataSafely(\r\n                    source.source as any,\r\n                    source\r\n                );\r\n            });\r\n\r\n            if (result.success && result.dataModel) {\r\n                console.log(`\u2705 Successfully loaded from data source ${i + 1}`);\r\n\r\n                // Cache successful result\r\n                if (config.cacheOptions?.enabled) {\r\n                    await this.saveToCache(result.dataModel, config.cacheOptions.path);\r\n                }\r\n\r\n                return result;\r\n            }\r\n\r\n            lastResult = result;\r\n\r\n            if (!isLastSource) {\r\n                console.log(`\u274c Data source ${i + 1} failed, trying next...`);\r\n            }\r\n        }\r\n\r\n        console.log('\u274c All data sources failed');\r\n        return lastResult || {\r\n            success: false,\r\n            errors: ['All data sources failed'],\r\n            warnings: []\r\n        };\r\n    }\r\n\r\n    private tryLoadFromCache(cachePath: string, ttl: number): LoadResult {\r\n        try {\r\n            if (!fs.existsSync(cachePath)) {\r\n                return { success: false, errors: ['Cache file not found'], warnings: [] };\r\n            }\r\n\r\n            const stats = fs.statSync(cachePath);\r\n            const age = (Date.now() - stats.mtime.getTime()) / 1000;\r\n\r\n            if (age > ttl) {\r\n                return { success: false, errors: ['Cache expired'], warnings: [] };\r\n            }\r\n\r\n            const cacheData = JSON.parse(fs.readFileSync(cachePath, 'utf8'));\r\n\r\n            // Reconstruct AttackDataModel from cached data\r\n            // (This would need custom deserialization logic)\r\n\r\n            return {\r\n                success: true,\r\n                errors: [],\r\n                warnings: [`Using cached data (${Math.round(age)}s old)`]\r\n            };\r\n\r\n        } catch (error) {\r\n            return {\r\n                success: false,\r\n                errors: [`Cache load failed: ${error}`],\r\n                warnings: []\r\n            };\r\n        }\r\n    }\r\n\r\n    private async saveToCache(dataModel: AttackDataModel, cachePath: string): Promise<void> {\r\n        try {\r\n            // Create cache directory if it doesn't exist\r\n            const cacheDir = path.dirname(cachePath);\r\n            if (!fs.existsSync(cacheDir)) {\r\n                fs.mkdirSync(cacheDir, { recursive: true });\r\n            }\r\n\r\n            // Serialize data model\r\n            const cacheData = {\r\n                timestamp: Date.now(),\r\n                techniques: dataModel.techniques,\r\n                tactics: dataModel.tactics,\r\n                groups: dataModel.groups,\r\n                // ... other collections\r\n            };\r\n\r\n            fs.writeFileSync(cachePath, JSON.stringify(cacheData, null, 2));\r\n            console.log(`\ud83d\udcbe Data cached to ${cachePath}`);\r\n\r\n        } catch (error) {\r\n            console.warn(`\u26a0\ufe0f  Failed to save cache: ${error}`);\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"step-6-error-reporting-and-monitoring",children:"Step 6: Error Reporting and Monitoring"}),"\n",(0,a.jsx)(n.p,{children:"Implement comprehensive error reporting:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface ErrorReport {\r\n    timestamp: string;\r\n    source: string;\r\n    errorType: string;\r\n    message: string;\r\n    context: any;\r\n    stackTrace?: string;\r\n}\r\n\r\nclass ErrorReporter {\r\n    private errors: ErrorReport[] = [];\r\n\r\n    reportError(source: string, error: unknown, context: any = {}): void {\r\n        const report: ErrorReport = {\r\n            timestamp: new Date().toISOString(),\r\n            source,\r\n            errorType: error instanceof Error ? error.constructor.name : 'Unknown',\r\n            message: error instanceof Error ? error.message : String(error),\r\n            context,\r\n            stackTrace: error instanceof Error ? error.stack : undefined\r\n        };\r\n\r\n        this.errors.push(report);\r\n\r\n        // Log to console\r\n        console.error(`\u274c [${source}] ${report.message}`, report.context);\r\n\r\n        // Send to monitoring service (implement based on your needs)\r\n        this.sendToMonitoring(report);\r\n    }\r\n\r\n    private sendToMonitoring(report: ErrorReport): void {\r\n        // Example: Send to external monitoring service\r\n        // fetch('/api/errors', {\r\n        //     method: 'POST',\r\n        //     headers: { 'Content-Type': 'application/json' },\r\n        //     body: JSON.stringify(report)\r\n        // });\r\n    }\r\n\r\n    getErrorSummary(): { [key: string]: number } {\r\n        const summary: { [key: string]: number } = {};\r\n\r\n        this.errors.forEach(error => {\r\n            summary[error.errorType] = (summary[error.errorType] || 0) + 1;\r\n        });\r\n\r\n        return summary;\r\n    }\r\n\r\n    getRecentErrors(hours: number = 24): ErrorReport[] {\r\n        const cutoff = new Date(Date.now() - hours * 60 * 60 * 1000);\r\n        return this.errors.filter(error => new Date(error.timestamp) > cutoff);\r\n    }\r\n}\r\n\r\n// Global error reporter instance\r\nconst errorReporter = new ErrorReporter();\n"})}),"\n",(0,a.jsx)(n.h2,{id:"step-7-application-level-error-handling",children:"Step 7: Application-Level Error Handling"}),"\n",(0,a.jsx)(n.p,{children:"Create a complete error handling solution:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface AppConfig {\r\n    dataSources: DataSourceConfig;\r\n    errorHandling: {\r\n        maxRetries: number;\r\n        enableCache: boolean;\r\n        cacheTtl: number;\r\n        failFast: boolean;\r\n    };\r\n    monitoring: {\r\n        enabled: boolean;\r\n        endpoint?: string;\r\n    };\r\n}\r\n\r\nclass AttackDataApp {\r\n    private config: AppConfig;\r\n    private loader: RobustAttackLoader;\r\n    private dataModel?: AttackDataModel;\r\n\r\n    constructor(config: AppConfig) {\r\n        this.config = config;\r\n        this.loader = new RobustAttackLoader();\r\n    }\r\n\r\n    async initialize(): Promise<void> {\r\n        try {\r\n            console.log('\ud83d\ude80 Initializing ATT&CK Data Application...');\r\n\r\n            const result = await this.loader.loadWithFallbacks(this.config.dataSources);\r\n\r\n            if (!result.success) {\r\n                const errorMsg = `Failed to initialize: ${result.errors.join(', ')}`;\r\n                errorReporter.reportError('App.initialize', new Error(errorMsg));\r\n\r\n                if (this.config.errorHandling.failFast) {\r\n                    throw new Error(errorMsg);\r\n                }\r\n\r\n                console.warn('\u26a0\ufe0f  Running with degraded functionality');\r\n                return;\r\n            }\r\n\r\n            this.dataModel = result.dataModel;\r\n\r\n            // Report warnings but continue\r\n            if (result.warnings.length > 0) {\r\n                result.warnings.forEach(warning => {\r\n                    console.warn(`\u26a0\ufe0f  ${warning}`);\r\n                });\r\n            }\r\n\r\n            console.log('\u2705 Application initialized successfully');\r\n\r\n        } catch (error) {\r\n            errorReporter.reportError('App.initialize', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // Safe method calls with error handling\r\n    async getTechnique(id: string): Promise<TechniqueImpl | null> {\r\n        try {\r\n            if (!this.dataModel) {\r\n                throw new Error('Application not initialized');\r\n            }\r\n\r\n            const technique = this.dataModel.techniques.find(t =>\r\n                t.external_references[0].external_id === id\r\n            );\r\n\r\n            return technique || null;\r\n\r\n        } catch (error) {\r\n            errorReporter.reportError('App.getTechnique', error, { id });\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Health check for monitoring\r\n    getHealthStatus(): {\r\n        status: 'healthy' | 'degraded' | 'unhealthy';\r\n        details: any;\r\n    } {\r\n        const recentErrors = errorReporter.getRecentErrors(1);\r\n        const errorCount = recentErrors.length;\r\n\r\n        if (!this.dataModel) {\r\n            return {\r\n                status: 'unhealthy',\r\n                details: {\r\n                    message: 'Data model not loaded',\r\n                    errors: errorCount\r\n                }\r\n            };\r\n        }\r\n\r\n        if (errorCount > 10) {\r\n            return {\r\n                status: 'degraded',\r\n                details: {\r\n                    message: `High error rate: ${errorCount} errors in last hour`,\r\n                    techniques: this.dataModel.techniques.length\r\n                }\r\n            };\r\n        }\r\n\r\n        return {\r\n            status: 'healthy',\r\n            details: {\r\n                techniques: this.dataModel.techniques.length,\r\n                tactics: this.dataModel.tactics.length,\r\n                uptime: process.uptime()\r\n            }\r\n        };\r\n    }\r\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"step-8-usage-example",children:"Step 8: Usage Example"}),"\n",(0,a.jsx)(n.p,{children:"Put it all together in a production-ready application:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"async function main() {\r\n    const config: AppConfig = {\r\n        dataSources: {\r\n            primary: new DataSource({\r\n                source: 'attack',\r\n                domain: 'enterprise-attack',\r\n                version: '15.1',\r\n                parsingMode: 'strict'\r\n            }),\r\n            fallbacks: [\r\n                new DataSource({\r\n                    source: 'attack',\r\n                    domain: 'enterprise-attack',\r\n                    parsingMode: 'relaxed' // More forgiving fallback\r\n                }),\r\n                new DataSource({\r\n                    source: 'file',\r\n                    file: './backup/enterprise-attack.json',\r\n                    parsingMode: 'relaxed'\r\n                })\r\n            ],\r\n            cacheOptions: {\r\n                enabled: true,\r\n                ttl: 3600, // 1 hour\r\n                path: './cache/attack-data.json'\r\n            }\r\n        },\r\n        errorHandling: {\r\n            maxRetries: 3,\r\n            enableCache: true,\r\n            cacheTtl: 3600,\r\n            failFast: false\r\n        },\r\n        monitoring: {\r\n            enabled: true\r\n        }\r\n    };\r\n\r\n    const app = new AttackDataApp(config);\r\n\r\n    try {\r\n        await app.initialize();\r\n\r\n        // Your application logic here\r\n        const technique = await app.getTechnique('T1055');\r\n        if (technique) {\r\n            console.log(`Found technique: ${technique.name}`);\r\n        }\r\n\r\n        // Monitor health\r\n        setInterval(() => {\r\n            const health = app.getHealthStatus();\r\n            console.log(`Health: ${health.status}`, health.details);\r\n        }, 60000); // Check every minute\r\n\r\n    } catch (error) {\r\n        console.error('\u274c Application failed to start:', error);\r\n        process.exit(1);\r\n    }\r\n}\r\n\r\nmain().catch(console.error);\n"})}),"\n",(0,a.jsx)(n.hr,{})]})}function h(r={}){const{wrapper:n}={...(0,o.R)(),...r.components};return n?(0,a.jsx)(n,{...r,children:(0,a.jsx)(u,{...r})}):u(r)}},7293:(r,n,e)=>{e.d(n,{A:()=>N});var t=e(6540),a=e(4848);function o(r){const{mdxAdmonitionTitle:n,rest:e}=function(r){const n=t.Children.toArray(r),e=n.find((r=>t.isValidElement(r)&&"mdxAdmonitionTitle"===r.type)),o=n.filter((r=>r!==e)),s=e?.props.children;return{mdxAdmonitionTitle:s,rest:o.length>0?(0,a.jsx)(a.Fragment,{children:o}):null}}(r.children),o=r.title??n;return{...r,...o&&{title:o},children:e}}var s=e(4164),i=e(1312),l=e(7559);const c="admonition_xJq3",d="admonitionHeading_Gvgb",u="admonitionIcon_Rf37",h="admonitionContent_BuS1";function p({type:r,className:n,children:e}){return(0,a.jsx)("div",{className:(0,s.A)(l.G.common.admonition,l.G.common.admonitionType(r),c,n),children:e})}function g({icon:r,title:n}){return(0,a.jsxs)("div",{className:d,children:[(0,a.jsx)("span",{className:u,children:r}),n]})}function m({children:r}){return r?(0,a.jsx)("div",{className:h,children:r}):null}function f(r){const{type:n,icon:e,title:t,children:o,className:s}=r;return(0,a.jsxs)(p,{type:n,className:s,children:[t||e?(0,a.jsx)(g,{title:t,icon:e}):null,(0,a.jsx)(m,{children:o})]})}function x(r){return(0,a.jsx)("svg",{viewBox:"0 0 14 16",...r,children:(0,a.jsx)("path",{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})})}const y={icon:(0,a.jsx)(x,{}),title:(0,a.jsx)(i.A,{id:"theme.admonition.note",description:"The default label used for the Note admonition (:::note)",children:"note"})};function w(r){return(0,a.jsx)(f,{...y,...r,className:(0,s.A)("alert alert--secondary",r.className),children:r.children})}function v(r){return(0,a.jsx)("svg",{viewBox:"0 0 12 16",...r,children:(0,a.jsx)("path",{fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"})})}const b={icon:(0,a.jsx)(v,{}),title:(0,a.jsx)(i.A,{id:"theme.admonition.tip",description:"The default label used for the Tip admonition (:::tip)",children:"tip"})};function j(r){return(0,a.jsx)(f,{...b,...r,className:(0,s.A)("alert alert--success",r.className),children:r.children})}function k(r){return(0,a.jsx)("svg",{viewBox:"0 0 14 16",...r,children:(0,a.jsx)("path",{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})})}const S={icon:(0,a.jsx)(k,{}),title:(0,a.jsx)(i.A,{id:"theme.admonition.info",description:"The default label used for the Info admonition (:::info)",children:"info"})};function M(r){return(0,a.jsx)(f,{...S,...r,className:(0,s.A)("alert alert--info",r.className),children:r.children})}function R(r){return(0,a.jsx)("svg",{viewBox:"0 0 16 16",...r,children:(0,a.jsx)("path",{fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"})})}const A={icon:(0,a.jsx)(R,{}),title:(0,a.jsx)(i.A,{id:"theme.admonition.warning",description:"The default label used for the Warning admonition (:::warning)",children:"warning"})};function D(r){return(0,a.jsx)("svg",{viewBox:"0 0 12 16",...r,children:(0,a.jsx)("path",{fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"})})}const E={icon:(0,a.jsx)(D,{}),title:(0,a.jsx)(i.A,{id:"theme.admonition.danger",description:"The default label used for the Danger admonition (:::danger)",children:"danger"})};const T={icon:(0,a.jsx)(R,{}),title:(0,a.jsx)(i.A,{id:"theme.admonition.caution",description:"The default label used for the Caution admonition (:::caution)",children:"caution"})};const C={...{note:w,tip:j,info:M,warning:function(r){return(0,a.jsx)(f,{...A,...r,className:(0,s.A)("alert alert--warning",r.className),children:r.children})},danger:function(r){return(0,a.jsx)(f,{...E,...r,className:(0,s.A)("alert alert--danger",r.className),children:r.children})}},...{secondary:r=>(0,a.jsx)(w,{title:"secondary",...r}),important:r=>(0,a.jsx)(M,{title:"important",...r}),success:r=>(0,a.jsx)(j,{title:"success",...r}),caution:function(r){return(0,a.jsx)(f,{...T,...r,className:(0,s.A)("alert alert--warning",r.className),children:r.children})}}};function N(r){const n=o(r),e=(t=n.type,C[t]||(console.warn(`No admonition component found for admonition type "${t}". Using Info as fallback.`),C.info));var t;return(0,a.jsx)(e,{...n})}},1367:(r,n,e)=>{e.d(n,{A:()=>o});e(6540);var t=e(7293),a=e(4848);function o(){return(0,a.jsx)(t.A,{type:"warning",title:"\ud83d\udea7 Work in Progress",icon:"\u26a0\ufe0f",children:"This document is a work in progress. Content may change, and some sections may be incomplete."})}},8453:(r,n,e)=>{e.d(n,{R:()=>s,x:()=>i});var t=e(6540);const a={},o=t.createContext(a);function s(r){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof r?r(n):{...n,...r}}),[n,r])}function i(r){let n;return n=r.disableParentContext?"function"==typeof r.components?r.components(a):r.components||a:s(r.components),t.createElement(o.Provider,{value:n},r.children)}}}]);