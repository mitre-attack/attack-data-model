import { describe, beforeEach, it, expect } from 'vitest';
import { v4 as uuidv4 } from 'uuid';
import { type Malware, malwareSchema } from '../../src/schemas/sdo/malware.schema';
import {
  type StixCreatedTimestamp,
  type StixModifiedTimestamp,
  type StixTimestamp,
  xMitreIdentity,
} from '../../src/schemas/common/index';

describe('MalwareSchema', () => {
  let minimalMalware: Malware;

  beforeEach(() => {
    minimalMalware = {
      type: 'malware',
      id: `malware--${uuidv4()}`,
      spec_version: '2.1',
      created_by_ref: `identity--${uuidv4()}`,
      created: '2017-05-31T21:32:29.203Z' as StixCreatedTimestamp,
      modified: '2021-02-09T13:58:23.806Z' as StixModifiedTimestamp,
      name: 'HAMMERTOSS',
      description:
        '[HAMMERTOSS](https://attack.mitre.org/software/S0037) is a backdoor that was used by [APT29](https://attack.mitre.org/groups/G0016) in 2015. (Citation: FireEye APT29) (Citation: F-Secure The Dukes)',
      external_references: [
        {
          source_name: 'mitre-attack',
          url: 'https://attack.mitre.org/software/S0037',
          external_id: 'S0037',
        },
      ],
      object_marking_refs: ['marking-definition--fa42a846-8d90-4e51-bc29-71d5b4802168'],
      x_mitre_attack_spec_version: '2.1.0',
      x_mitre_domains: ['enterprise-attack'],
      x_mitre_modified_by_ref: xMitreIdentity,
      is_family: false,
      x_mitre_version: '1.2',
    };
  });

  describe('Valid Inputs', () => {
    it('should accept minimal valid object (only required fields)', () => {
      expect(() => malwareSchema.parse(minimalMalware)).not.toThrow();
    });

    it('should accept fully populated valid object (required + optional ATT&CK fields)', () => {
      const fullMalware: Malware = {
        ...minimalMalware,
        x_mitre_platforms: ['Windows'],
        x_mitre_contributors: ['Contributor'],
        x_mitre_aliases: ['HAMMERTOSS', 'HammerDuke', 'NetDuke'],
        x_mitre_deprecated: false,
        x_mitre_old_attack_id: 'MOB-S0123',
      };
      expect(() => malwareSchema.parse(fullMalware)).not.toThrow();
    });

    it('should accept fully populated valid object (required + optional STIX fields)', () => {
      const fullMalware: Malware = {
        ...minimalMalware,
        kill_chain_phases: [
          {
            kill_chain_name: 'mitre-attack',
            phase_name: 'privilege-escalation',
          },
        ],
        aliases: ['HAMMERTOSS', 'HammerDuke', 'NetDuke'],
        first_seen: '2015-07-01T00:00:00.000Z' as StixTimestamp,
        last_seen: '2016-07-01T00:00:00.000Z' as StixTimestamp,
        malware_types: ['remote-access-trojan'],
        os_execution_envs: ['Windows', 'Linux'],
        architecture_execution_envs: ['x86'],
        capabilities: ['exfiltrates-data', 'accesses-remote-machines'],
        implementation_languages: ['python'],
        sample_refs: ['file--a3b8b3b2-4d2f-4a2e-9a1b-1c8b3e4e6f5d'],
      };
      expect(() => malwareSchema.parse(fullMalware)).not.toThrow();
    });
  });

  describe('Field-Specific Tests', () => {
    const testField = (
      fieldName: keyof Malware,
      invalidValue: any,
      isRequired = true, // Flag indicating whether the field is required
    ) => {
      it(`should reject invalid values for ${fieldName}`, () => {
        const invalidObject = { ...minimalMalware, [fieldName]: invalidValue };
        expect(() => malwareSchema.parse(invalidObject)).toThrow();
      });

      if (isRequired) {
        it(`should reject omission of ${fieldName}`, () => {
          const { [fieldName]: omitted, ...objectWithoutField } = minimalMalware;
          expect(() => malwareSchema.parse(objectWithoutField)).toThrow();
        });
      } else {
        it(`should accept omission of ${fieldName}`, () => {
          const { [fieldName]: omitted, ...objectWithoutField } = minimalMalware;
          expect(() => malwareSchema.parse(objectWithoutField)).not.toThrow();
        });
      }
    };

    // Testing required fields
    describe('id', () => {
      testField('id', 'invalid-id');
    });

    describe('type', () => {
      testField('type', 'invalid-type');
    });

    describe('is_family', () => {
      testField('is_family', 'invalid-is-family');
    });

    // Testing optional fields
    describe('malware_types', () => {
      testField('malware_types', ['invalid-malware-type'], false);
    });

    describe('kill_chain_phases', () => {
      testField('kill_chain_phases', [{ invalid: 'object' }], false);
    });

    describe('first_seen', () => {
      testField('first_seen', 'invalid-date', false);
    });

    describe('last_seen', () => {
      testField('last_seen', 'invalid-date', false);
    });

    describe('os_execution_envs', () => {
      testField('os_execution_envs', 'not-an-array', false);
    });

    describe('architecture_execution_envs', () => {
      testField('architecture_execution_envs', ['invalid-architecture'], false);
    });

    describe('implementation_languages', () => {
      testField('implementation_languages', ['invalid-language'], false);
    });

    describe('capabilities', () => {
      testField('capabilities', ['invalid-capability'], false);
    });

    describe('sample_refs', () => {
      testField('sample_refs', 'invalid-sample-ref', false);
    });

    describe('x_mitre_aliases', () => {
      testField('x_mitre_aliases', 'not-an-array', false);
    });
  });

  describe('Schema Refinements', () => {
    describe('External References Validation', () => {
      it('should reject when ATT&CK ID is missing', () => {
        const invalidMalware = {
          ...minimalMalware,
          external_references: [{ source_name: 'mitre-attack' }],
        };
        expect(() => malwareSchema.parse(invalidMalware)).toThrow(/ATT&CK ID must be defined/);
      });

      it('should reject invalid ATT&CK ID format', () => {
        const invalidMalware = {
          ...minimalMalware,
          external_references: [{ source_name: 'mitre-attack', external_id: 'S123' }],
        };
        expect(() => malwareSchema.parse(invalidMalware)).toThrow(
          /must match the ATT&CK ID format S####/,
        );
      });
    });

    describe('x_mitre_aliases Validation', () => {
      it("should reject when the first alias does not match the object's name", () => {
        const invalidMalware = {
          ...minimalMalware,
          x_mitre_aliases: ['HammerDuke'],
        };
        expect(() => malwareSchema.parse(invalidMalware)).toThrow(
          /The first alias must match the object's name/,
        );
      });
    });

    describe('x_mitre_old_attack_id Validation', () => {
      it('should reject when x_mitre_old_attack_id is not in format MOB-S####', () => {
        const invalidMalware = {
          ...minimalMalware,
          x_mitre_old_attack_id: 'MOB-M0123',
        };
        expect(() => malwareSchema.parse(invalidMalware)).toThrow(
          /x_mitre_old_attack_id for malware need to be in the format MOB-S####/,
        );
      });
    });
  });

  describe('Schema-Level Tests', () => {
    it('should reject unknown properties', () => {
      const malwareWithUnknownProperty = {
        ...minimalMalware,
        unknown_property: 'unexpected_value',
      };
      expect(() => malwareSchema.parse(malwareWithUnknownProperty)).toThrow();
    });
  });
});
